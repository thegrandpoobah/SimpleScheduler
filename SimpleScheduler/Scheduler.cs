using NGenerics.DataStructures.Queues;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading;

namespace SimpleScheduler
{
    public class Scheduler : IDisposable
    {
        private PriorityQueue<Job, double> queue;
        private Dictionary<Guid, Job> map;
        private System.Timers.Timer timer;
        private DateTime startTime;
        private object syncObject = new object();

        public Scheduler()
        {
            Active = true;

            queue = new PriorityQueue<Job, double>(PriorityQueueType.Minimum);
            map = new Dictionary<Guid, Job>();

            timer = new System.Timers.Timer()
            {
                AutoReset = false,
                Enabled = false
            };
            timer.Elapsed += onTimerElapsed;
            startTime = DateTime.UtcNow;
        }

        /// <summary>
        /// Determines if the scheduler should be actively handling tasks or not.
        /// </summary>
        public bool Active
        {
            get;
            set;
        }

        /// <summary>
        /// Adds a job to the queue.
        /// </summary>
        /// <param name="action">The action to run once the elapsed period has expired.</param>
        /// <param name="millisecondsToTrigger">Number of milliseconds to wait before triggering the task.</param>
        /// <returns>A value that identifies this task in the system.</returns>
        public Guid AddJob(Action action, double millisecondsToTrigger)
        {
            Job job = new Job()
            {
                Id = Guid.NewGuid(),
                Action = action,
                MillisecondsToTrigger = millisecondsToTrigger,
                Enabled = true
            };

            AddJob(job);

            return job.Id;
        }

        /// <summary>
        /// Adds a job to the queue.
        /// </summary>
        /// <param name="action">The action to run once the elapsed period has expired.</param>
        /// <param name="millisecondsToTrigger">Number of milliseconds to wait before triggering the task.</param>
        /// <param name="param">The parameter to pass to the action.</param>
        /// <returns>A value that identifies this task in the system.</returns>
        public Guid AddJob<T>(Action<T> action, double millisecondsToTrigger, T param)
        {
            return AddJob(() =>
            {
                action(param);
            }, millisecondsToTrigger);
        }

        private void AddJob(Job job)
        {
            DateTime nextTrigger = DateTime.UtcNow.AddMilliseconds(job.MillisecondsToTrigger);

            lock (syncObject)
            {
                map.Add(job.Id, job);
                queue.Add(job, (nextTrigger.ToUniversalTime() - startTime).TotalMilliseconds);
            }

            ScheduleTask();
        }

        /// <summary>
        /// Removes a job from the queue.
        /// </summary>
        /// <param name="id">The id of the job to remove from the system (this id is generated by AddJob)</param>
        public void RemoveJob(Guid id)
        {
            lock (syncObject)
            {
                if (!map.ContainsKey(id))
                {
                    return;
                }

                map[id].Enabled = false;
                map.Remove(id);
            }
        }

        private void ScheduleTask()
        {
            double priority = TimeSpan.MaxValue.TotalMilliseconds;

            lock (syncObject)
            {
                if (queue.Count == 0)
                {
                    return;
                }

                queue.Peek(out priority);
            }

            double interval = (startTime.AddMilliseconds(priority) - DateTime.UtcNow).TotalMilliseconds;
            if (interval <= 0)
            {
                PerformAction();
            }
            else
            {
                timer.Interval = interval;
                timer.Enabled = true;
            }
        }

        private void onTimerElapsed(object sender, System.Timers.ElapsedEventArgs e)
        {
            PerformAction();
        }

        private void PerformAction()
        {
            Job job = null;

            lock (syncObject)
            {
                if (queue.Count == 0)
                {
                    return;
                }

                job = queue.Dequeue();
            }

            Debug.Assert(job != null);

            if (Active && job.Enabled)
            {
                ThreadPool.QueueUserWorkItem(arg =>
                {
                    if (!job.Enabled)
                    {
                        return;
                    }

                    job.Action();

                    RemoveJob(job.Id);
                });
            }

            ScheduleTask();
        }

        public void Dispose()
        {
            Active = false;

            timer.Dispose();
        }
    }
}