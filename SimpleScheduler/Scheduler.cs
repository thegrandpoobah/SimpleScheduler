using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Web;
using NGenerics.DataStructures.Queues;

namespace SimpleScheduler
{
    public class Scheduler : IDisposable
    {
        private PriorityQueue<Job, double> queue;
        private Dictionary<Guid, Job> map;
        private System.Timers.Timer timer;
        private DateTime startTime;

        public Scheduler()
        {
            Active = true;

            queue = new PriorityQueue<Job, double>(PriorityQueueType.Minimum);
            map = new Dictionary<Guid, Job>();

            timer = new System.Timers.Timer()
            {
                AutoReset = false,
                Enabled = false
            };
            timer.Elapsed += onTimerElapsed;
            startTime = DateTime.UtcNow;
        }

        /// <summary>
        /// Determines if the scheduler should be actively handling tasks or not.
        /// </summary>
        public bool Active
        {
            get;
            set;
        }

        /// <summary>
        /// Adds a job to the queue.
        /// </summary>
        /// <param name="action">The action to run once the elapsed period has expired.</param>
        /// <param name="millisecondsToTrigger">Number of milliseconds to wait before triggering the task.</param>
        /// <returns>A value that identifies this task in the system.</returns>
        public Guid AddJob(Action action, double millisecondsToTrigger)
        {
            Job job = new Job()
            {
                Id = Guid.NewGuid(),
                Action = action,
                MillisecondsToTrigger = millisecondsToTrigger,
                Enabled = true
            };

            map.Add(job.Id, job);
            AddJob(job);

            return job.Id;
        }

        /// <summary>
        /// Adds a job to the queue.
        /// </summary>
        /// <param name="action">The action to run once the elapsed period has expired.</param>
        /// <param name="millisecondsToTrigger">Number of milliseconds to wait before triggering the task.</param>
        /// <param name="param">The parameter to pass to the action.</param>
        /// <returns>A value that identifies this task in the system.</returns>
        public Guid AddJob<T>(Action<T> action, double millisecondsToTrigger, T param)
        {
            return AddJob(() =>
            {
                action(param);
            }, millisecondsToTrigger);
        }

        private void AddJob(Job job)
        {
            DateTime nextTrigger = DateTime.UtcNow.AddMilliseconds(job.MillisecondsToTrigger);

            queue.Add(job, (nextTrigger.ToUniversalTime() - startTime).TotalMilliseconds);

            ScheduleTask();
        }

        /// <summary>
        /// Removes a job from the queue.
        /// </summary>
        /// <param name="id">The id of the job to remove from the system (this id is generated by AddJob)</param>
        public void RemoveJob(Guid id)
        {
            if (map.ContainsKey(id))
            {
                map[id].Enabled = false;
                map.Remove(id);
            }
        }

        private void ScheduleTask()
        {
            if (queue.Count == 0)
            {
                return;
            }

            double priority;
            queue.Peek(out priority);

            double interval = (startTime.AddMilliseconds(priority) - DateTime.UtcNow).TotalMilliseconds;
            if (interval <= 0)
            {
                PerformAction();
            }
            else
            {
                timer.Interval = interval;
                timer.Enabled = true;
            }
        }

        private void onTimerElapsed(object sender, System.Timers.ElapsedEventArgs e)
        {
            PerformAction();
        }

        private void PerformAction()
        {
            if (queue.Count == 0)
            {
                return;
            }

            Job job = queue.Dequeue();

            if (Active && job.Enabled)
            {
                ThreadPool.QueueUserWorkItem(arg =>
                {
                    if (!job.Enabled)
                    {
                        return;
                    }

                    job.Action();
                });
            }

            ScheduleTask();
        }

        public void Dispose()
        {
            Active = false;
            timer.Dispose();
        }
    }
}